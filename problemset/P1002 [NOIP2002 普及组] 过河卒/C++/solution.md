# 过河卒 - NOIP2002 普及组

## 题目链接

[过河卒](https://www.luogu.com.cn/problem/P1002)

## 题目描述

棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 解题思路

该问题可以使用动态规划的思想进行求解。这个问题的状态转移方程较为简单，当前点的路径数量等于左边点和上面点的路径数量之和，因为卒只能向下或者向右移动。

对于棋盘上的每个点，我们使用一个二维数组dp[i][j]表示卒到达该点的路径数量。初始化时，对于棋盘的第一行和第一列，卒只有一种走法，即一直沿着边走到该点，所以我们将dp数组的第一行和第一列的所有点初始化为1。

然后，我们从左到右、从上到下遍历棋盘上的每一个点，如果这个点是马或者马控制的点，则dp[i][j]设为0，表示不能通过该点；否则，dp[i][j]等于dp[i-1][j]和dp[i][j-1]的和。

最后，dp[n][m]就是我们需要求解的卒从A点到B点的所有路径数量。

## 代码

以下是用C++实现的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, m, dx, dy;
int a[22][22], dp[22][22];
int dx1[9] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
int dy1[9] = {0, -1, -2, -2, -1, 1, 2, 2, 1};

int main() {
    cin >> n >> m >> dx >> dy;
    a[dx][dy] = 1;
    for (int i = 0; i < 9; i++)
        if (dx+dx1[i] >= 0 && dx+dx1[i] <= n && dy+dy1[i] >= 0 && dy+dy1[i] <= m)
            a[dx+dx1[i]][dy+dy1[i]] = 1;
    dp[0][0] = 1;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= m; j++)
            if (!a[i][j]) {
                if (i) dp[i][j] += dp[i-1][j];
                if (j) dp[i][j] += dp[i][j-1];
            }
    cout << dp[n][m] << endl;
    return 0;
}
```

## 优化

上述代码已经利用动态规划的思想解决了这个问题，并且使用了适当的数据结构进行存储，因此代码本身就已经非常优化，执行效率较高，时间复杂度为O(nm)，空间复杂度也为O(nm)。

## 其他方案

题目的解决方案基本上就是动态规划，这种解决方式已经非常优秀，无需考虑其他方案。

## 结论

本题是一道典型的动态规划问题，解决这类问题的关键在于找到状态转移方程，即找到每个状态与其前驱状态之间的关系。在实际编程中，我们需要用一个合适的数据结构存储所有的状态，然后按照状态转移方程来更新每个状态，最后的结果就存储在我们需要的状态中。在这个过程中，我们还需要处理一些特殊情况，如题目中的马和马所控制的点。这需要我们在更新状态时进行判断，防止错误的状态转移。