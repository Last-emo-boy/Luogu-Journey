# 过河卒 - NOIP2002 普及组

## 题目链接

[过河卒 - NOIP2002 普及组](https://www.luogu.com.cn/problem/P1002)

## 题目描述

在一个棋盘上，有一个过河卒在A点，需要到达B点。卒只能向下或者向右行走。在棋盘上还有一个马在C点，马的位置以及马跳一步可到达的位置都是马的控制点，卒不能经过马的控制点。求卒从A点到B点的路径数。

## 解题思路

这个问题可以使用动态规划的方法来解决。我们可以建立一个二维的dp数组，dp[i][j]表示卒从A点到达点(i, j)的路径数。

初始化时，首先标记马的位置以及马可以跳到的位置为不可达，然后从(0, 0)开始向右和向下走，如果当前位置可达，那么路径数为1。

然后，从(0, 0)开始，依次计算每个点的路径数。因为卒只能向下或者向右行走，所以到达点(i, j)的路径数就是到达点(i-1, j)的路径数加上到达点(i, j-1)的路径数，即dp[i][j] = dp[i-1][j] + dp[i][j-1]。如果点(i, j)不可达，那么路径数为0。

## 代码

以下是使用Python3解决这个问题的代码：

```python
n, m, hx, hy = map(int, input().split())
dx = [0, 1, -1, 2, -2, 2, -2, 1, -1]
dy = [0, 2, 2, 1, 1, -1, -1, -2, -2]
dp = [[0] * (m+1) for _ in range(n+1)]
dp[0][0] = 1
for i in range(9):
    x = hx + dx[i]
    y = hy + dy[i]
    if x >= 0 and x <= n and y >= 0 and y <= m:
        dp[x][y] = -1

for i in range(n+1):
    for j in range(m+1):
        if dp[i][j] != -1:
            if i-1 >= 0 and dp[i-1][j] != -1:
                dp[i][j] += dp[i-1][j]
            if j-1 >= 0 and dp[i][j-1] != -1:
                dp[i][j] += dp[i][j-1]

print(dp[n][m] if dp[n][m] != -1 else 0)
```

## 优化
关于这个问题，使用动态规划已经是相当优化的方法了，时间复杂度为O(n*m)，空间复杂度也为O(n*m)，由于棋盘大小并不大，所以在时间和空间上都是可以接受的。

如果要进一步优化，我们可以考虑空间复杂度的优化。我们可以看到，dp[i][j]只依赖于dp[i-1][j]和dp[i][j-1]，也就是说，我们在计算dp[i][j]的时候，只需要知道当前行的上一行和当前行的前一个元素，所以我们并不需要保存整个dp矩阵，只需要保存当前行和上一行就可以了。这样我们可以将空间复杂度从O(n*m)优化到O(2*m)，也就是O(m)。这在处理大规模问题时，会有较大的优势。

以下是优化后的Python3代码：

```python
n, m, hx, hy = map(int, input().split())
dx = [0, 1, -1, 2, -2, 2, -2, 1, -1]
dy = [0, 2, 2, 1, 1, -1, -1, -2, -2]
dp = [[0] * (m+1) for _ in range(2)]
dp[0][0] = 1
for i in range(9):
    x = hx + dx[i]
    y = hy + dy[i]
    if x >= 0 and x <= n and y >= 0 and y <= m:
        dp[x%2][y] = -1

for i in range(n+1):
    for j in range(m+1):
        if dp[i%2][j] != -1:
            if i-1 >= 0 and dp[(i-1)%2][j] != -1:
                dp[i%2][j] += dp[(i-1)%2][j]
            if j-1 >= 0 and dp[i%2][j-1] != -1:
                dp[i%2][j] += dp[i%2][j-1]

print(dp[n%2][m] if dp[n%2][m] != -1 else 0)
```

## 其他方案
这个问题实际上是一个基础的动态规划问题，解法相对固定，如果想要尝试其他方法，可以考虑回溯法或者深度优先搜索（DFS），但是由于这个问题的规模较大，所以这些方法在时间上可能不如动态规划方法效率高。

## 结论

这个问题是一个基础的动态规划问题，通过这个问题，我们可以学习到以下几点：

1. 如何使用动态规划解决问题。
2. 如何建立和初始化动态规划的状态

转移方程。
3. 动态规划的边界条件处理。

虽然这个问题比较简单，但是它涵盖了动态规划的一些基础知识，这些知识在解决更复杂的动态规划问题时非常有用。